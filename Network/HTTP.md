# HTTP (HyperText Transfer Protocol)

> 인터넷 상에서 서버와 클라이언트 자원을 주고받을 때 쓰는 프로토콜
>
> 응용계층에 속하고 TCP/IP 위에서 동작하며, 일반적으로 80번 포트를 통해 클라이언트가 서버에 요청

## HTTP 특징

### Connectionless

- 클라이언트가 서버에 연결하고, **요청해서 응답을 받으면 연결을 끊는다.**
- **불특정 다수를 대상**으로 하는 서비스에 적합

</br>

### Stateless

- 연결을 끊어버리기때문에, **클라이언트의 이전상태를 알 수 없다.**
- 이전에 로그인을해도 다시 들어가면 로그인 상태를 알 수 없음 
  => **Cookie/Session으로 보완**

</br>

## HTTP Method

> 특정 주소에 대해 어떤 동작을 하려고 할 때 사용하는 메서드

1. **GET**

   - 서버에게 리소스를 보내달라고 요청 (**읽기/검색 시 사용**)
   - 같은 요청을 여러 번 하더라도 변함없이 같은 응답을 받음

   </br>

2. **POST**

   - 서버에게 리소스를 보내면서 **생성**해달라고 요청

   - 구체적으로 **부모 리소스의 하위 리소스들을 생성하는데 사용**

   - 요청을 반복해서 했을 떄 항상 같은 결과물이 나오는 것을 보장하지 않음

     (회원가입을 하면 DB에 새로운 회원정보 등록, 사진 업로드 시 웹사이트에 등록)

   - 클라이언트에서 **서버로 전송할 때 추가적인 데이터를 body에 포함**할 수 있다.

   </br>

   +) **GET vs POST**

   ![](image\GETvsPOST.png)

   </br>

3. **PUT**

   - 서버에 리소스를 **업데이트**하거나 리소스가 없다면 새로운 리소스를 **생성**해달라고 요청

   - 특정 데이터를 업데이트할 때, 항상 **모든 필드값을 요청**해서 새로운 값으로 교체

     (ex.회원 정보 수정)

   </br>

4. **DELETE**

   - 서버에게 리소스의 **삭제**를 요청

</br>

참고: [https://velog.io/@pa324/%EA%B0%9C%EB%B0%9C%EC%83%81%EC%8B%9D-HTTP-GETPOST-%EB%B9%84%EA%B5%90](https://velog.io/@pa324/개발상식-HTTP-GETPOST-비교)

</br>

## HTTP status code

응답 상태 코드를 통해 성공/실패 여부를 확인할 수 있음

10X: 정보 확인

20X: 통신 성공

30X: 리다이렉트

40X: 클라이언트 오류

50X: 서버 오류

</br>

## HTTP vs HTTPS

### HTTP의 문제점

* 텍스트를 교환하는 방법으로 통신해서 메시지의 의미를 파악할 수 있어 도청이 가능
* **통신 상대를 확인하지 않아 request가 오면 상대가 누구든지 response**
* 리퀘스트나 리스폰스가 발신된 후에 상대가 수신하는 사이에 누군가에 의해 변조되더라도 이 사실을 알 수 없다 (중간자공격)

</br>

### HTTPS

* HTTP에 암호화, 인증, 완전성 보호를 더함

* SSL의 껍질을 덮어쓴 HTTP (새로운 프로토콜이 아님)

* HTTP는 원래 TCP와 직접 통신했지만, HTTPS는 **SSL과 통신하고 SSL이 TCP와 통신**한다.

* 단점: 암호화통신은 CPU/메로리 등의 리소스가 많이 필요 

  -> 통신할 때 마다 암호화를 하면 서버 한대당 처리할 수 있는 리퀘스트 수가 줄어든다.

>  **SSL (Secure Sockets Layer)** (=TLS)
>
> 클라이언트와 서버 간의 통신을 제 3자가 보증해주는 전자화된 문서로, HTTPS를 제공하기 위한 보안 기술
>
> > **과정**
> >
> > 1. 웹브라우저) SSL로 암호화된 페이지를 요청 (일반적으로 https)
> > 2. 웹서버) Public Key와 인증서를 전송
> > 3. 웹브라우저) 인증서 검증 후 public key를 사용해서 랜덤 대칭 암호화키를 비롯한 URL, http 데이터들을 암호화해서 전송
> > 4. 웹서버) private key를 이용해 랜덤대칭 암호화키와 URL, http 데이터를 복호화하고, URL에 대한 응답을 다시 암호화해서 브라우저로 전송
> > 5. 웹브라우저) 대칭키를 이용해 http데이터와 html문서를 복호화하고, 화면에 정보를 뿌려줌

</br>

참고: https://opentutorials.org/course/228/4894