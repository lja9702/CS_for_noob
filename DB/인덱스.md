# 인덱스 기본 개념

데이터 접근을 신속하게 하는 기능을 제공한다.

**두 종류**의 인덱스가 존재

- 정렬색인

- 해쉬색인

  

정렬색인의 경우 범위 질의 수행이 효율적

해쉬색인은 해쉬함수로 O(1)의 접근이 가능하지만 범위 질의에는 효율적이지 못함



### 정렬색인

---

**Clustering Index(Primary Index)**

- 키의 순서대로 데이터가 정렬된 인덱스

- 정렬 키로 보통 PK가 이용되지만 필수는 아니다.

  

**Non-Clustering Index(Secondary Index)**

- 데이터 레코드가 정렬되지 않은 상태로 저장

- 색인은 정렬되어 있는 상태

- 동일 데이터 파일에 다수가 존재할 수 있음

- 해시 색인과 유사하게 버켓을 이용해 간접적으로 포인팅하는 구조를 사용

    → 데이터가 정렬되지 않은 상태이고 동일값이 존재할 수 있기 때문에
    
    

**Dense Index(밀집색인)**

- **모든** 탐색키 값에 대해 색인 레코드가 색인

  

**Spare Inderx(희소색인)**

- 모든 값이 색인 레코드에 존재하지 않은 인덱스
- 그렇기 때문에 **Non-clustering index에는 적용할 수 없다.**

    → 정렬된 상태여야만 희소 색인이 유효하므로

- 공간은 적게 차지하지만 검색하는데 더 많은 시간을 요구
- 같은 **블록에 속하는 레코드의 가장 작은 값**으로 구성

    → 검색 시간이 길다는 단점을 보완할 수 있다.

    → 블록 내 연산은 메모리 상의 연산이므로 오버헤드가 적기 때문

    **희소 색인의 갱신 연산**

    데이터 파일에 변경이 발생하면 색인 파일에도 갱신해야한다.

    - 삭제 연산

        희소 색인의 키 값이 삭제되었을 경우

        → 같은 블록 내의 그 다음으로 큰 값이 인덱스 테이블의 엔트리에 추가된다.

        키 값이 아닌 값이 삭제되었을 경우

        → 엔트리에는 변화가 없다.

    - 삽입 연산

        이미 존재하는 블록에 추가되었을 경우

        → 엔트리는 그대로 유지된다.

        새 블록을 생성하고 추가되었을 경우

        → 엔트리에 해당 키 값이 추가된다.
        
        

**Multilevel Index(다단계 색인)**

색인 파일에 엔트리가 많으면 색인 파일을 대상으로 다른 색인을 구성한다.

정렬 색인은 검색키를 기준으로 정렬되어 있으므로 상위 색인은 **희소색인으로 구성**하여

파일크리를 줄인다.

**일반적으로 색인을 사용하면 검색시간이 향상**

**하지만 Non-clustering Index를 Sequential scan에 사용하면 비효율적이다.**

→ 이차색인 레코드를 순서대로 탐색할 경우 **동일 데이터블록을 1회이상 탐색할수도 있기 때문**